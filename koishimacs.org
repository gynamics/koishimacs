#+title: Emacs Literate Startup
#+author: gynamics
#+date: <2025-07-21 Mon>
#+property: header-args :tangle yes

* Prelude
** preface
Principles of my Emacs configuration:

1. less is more: policy rather than framework
2. iterability: always ease to modify rather than contiguous integration
3. readability: representation determines control structure while interaction methods determine representation

By (1) and (2), I just separate configurations into code blocks and ~use-package~ statements. As for cross-block dependencies, they can be removed by
1. internal dependency serialization: adjust loading order with ~use-package~ keywords, hooks and other emacs utilities.
2. external dependency integration: push these variables forward with some helpers.
so that all packages can be loosely coupled. I just care about if a package can be joined or replaced with minimal affects, rather than if a package can be joined in the same manner. Even a heavy refactorization shouldn't bother the existing code unless there is a significant change in package management.

By (3), ~org-mode~ can organize everything for me. I do not need a sparse directory tree with annoying abstract levels, and I can edit this document as efficient as edit a project in an IDE, because lisp is good at process nested structures, and org document itself is a tree.

My main goal is to produce a portable configuration that can be easily ported to a new machine, and then keep iterating with it. If you believe that there will never be an ultimate Emacs configuration for you, then why not embrace this stinging world and enjoy a thorny road?

** header
More and more packages, more and more configuration code, it turns to be more and more inconvenient to browse them in a single ~init.el~. However, if we separate them into multiple files, it actually exacerbates the dilemma of loose configuration management.

Therefore we will need a method to organize that large configuration file, both conceptually and visually. Although this could be achieved by a variety of tools in Emacs IDE without bothering the code itself, a more powerful approach is to bring everything into an org document.

This configuration style make use of ~org-babel-load-file~, with ~org-mode~, we can slice these emacs configuration blocks into smaller and smaller code blocks with good document (and all kinds of other information related) attached, which are always well organized in a tree.

This is the header of generated file:

#+begin_src emacs-lisp
  ;;; koishimacs.el --- auto-generated configuration -*- lexical-binding: t -*-

  ;; Author: gynamics
  ;; Version: 5.11.0

  ;;; Commentary:

  ;; Koishimacs -- The Emacs in Your Subconsciousness
  ;; This file is auto-generated from org blocks.

  ;;; Code:

  ;; check if current Emacs version supports this configuration
  (when (< emacs-major-version 30)
    (error "This Emacs version is not supported"))
#+end_src

You modifications in org code blocks will not take effect until next startup. If you want some options take effect immediately for further operations (e. g. set ~use-package-deferring-keywords~), you can evaluate them immediately with ~C-x C-e~ (~eval-last-sexp~).

** startup
Literate startup document needs to be tangled into a single ~.el~ or ~.elc~ file, because ~org-babel-tangle-file~ will take a little bit of time to tangle a series of blocks. You can then compile this file, but that doesn't matter performance.

BTW, most user-defined configuration interfaces has prefix ~my:~, and variables has prefix ~my/~. Just a personal naming style.

#+begin_src emacs-lisp
  (defun my:tangle-koishimacs:full (byte-compile-p)
    "Tangle all code blocks in koishimacs.org and write them to koishimacs.el .
  If BYTE-COMPILE-P is given as t, byte compile it."
    (interactive "P")
    (let ((source-file (concat user-emacs-directory "koishimacs.org"))
          (output-file (concat user-emacs-directory "koishimacs.el")))
      (org-babel-tangle-file source-file output-file)
      (when byte-compile-p
        (let ((byte-compile-warnings
               '(not free-vars unresolved noruntime lexical make-local)))
          (byte-compile-file output-file)))))
#+end_src

Early evaluation takes place in the compiling process, this will slightly reduce some work like patching and updating packages. If there happened to be something wrong with a code block, you can add ~:tangle no~ after ~#+begin_src emacs-lisp~ to skip it when compiling, then recompile the configuration file and debug that block manually on next startup.

** environment
There are several helpers help create or neglect missing files in initialization. A more generic implementation is expected here (e . g. add ~:depends~ or ~:import~ keywords to ~use-package~, but this seems to be unnecessary)

#+begin_src emacs-lisp
  (defun my:strong-directory (dir &optional parents)
    "Return DIR, if it does not exist, try to create it."
    (if (file-directory-p dir)
        dir
      (condition-case nil
          (make-directory dir parents)
        (:success dir)
        (error "failed to create directory %s" dir))))

  (defun my:weak-directory (dir)
    "Return DIR, if it does not exist return nil."
    (when (file-directory-p dir) dir))

  (defun my:weak-path (path)
    "Return PATH, if it does not exist return nil."
    (when (file-exists-p path) path))

  (defun my:weak-directory-override (sym dir)
    "Override the value of symbol SYM with DIR if it exists."
    (unless (symbolp sym)
      (error "%S is not a symbol!" sym))
    (when (file-directory-p dir)
      (set sym dir)))
#+end_src

~setenv~ will just set environment variable for current emacs process, in ~process-environment~.

However, if we start a subprocess from emacs, it uses environment variables inherited from the parent process of Emacs, which provides ~initial-environment~. To change this, we should modify variable ~exec-path~.

#+begin_src emacs-lisp
  (defun my:add-to-env-path (paths)
    "Add path strings in list PATHS to environment variable $PATH."
    (let ((env-path (split-string-and-unquote (getenv "PATH") ":")))
      (setenv "PATH" (mapconcat 'identity (append paths env-path) ":"))))

  (defun my:add-to-exec-path (paths)
    "Add path strings in list PATHS to list var EXEC-PATH."
    (setf exec-path (append paths exec-path)))

  (defun my:strip-list (&rest args)
    "Construct a list with ARGS, remove nils in ARGS."
    (mapcan (lambda (arg) (when arg (list arg))) args))

  (defun my:add-to-path (&rest paths)
    "Add path string PATHS to both $PATH and EXEC-PATH."
    (let ((l (apply #'my:strip-list paths)))
      (when l
        (my:add-to-env-path l)
        (my:add-to-exec-path l))))

  (let ((home (file-name-as-directory (getenv "HOME"))))
    ;; for some local tools, this should be added to PATH earlier
    (my:add-to-path
     (my:weak-directory (concat home ".local/bin")))

    ;; add additional paths to PATH as well as exec-path
    (my:add-to-path
     ;; extend the value of EXEC-PATH and $PATH here
     ;; for haskell
     (my:weak-directory (concat home ".ghcup/bin"))
     (my:weak-directory (concat home ".cabal/bin"))
     ;; for rust
     (my:weak-directory (concat home ".cargo/bin"))
     ;; for ruby
     (when (executable-find "gem")
       (shell-command-to-string "gem env user_gemhome | tr -d \"\\n\"")))

    ;; set additional environment variables
    (mapc
     (lambda (kv) (apply #'setenv kv))
     (my:strip-list
      ;; for go
      (when (file-directory-p (concat home ".go"))
        `("GOPATH" ,(concat home ".go")))
      ;; proxy (if you have one)
      '("http_proxy" "http://127.0.0.1:2080")
      '("https_proxy" "http://127.0.0.1:2080")
      '("ALL_PROXY" "socks5://127.0.0.1:2080")))
    )
#+end_src

** package manager
As for package configuration, we will use ~use-package.el~, which provides convenient syntactic sugar macros. ~use-package~ is the built-in package management framework for emacs29+ and can get packages from package sources automatically with ~package.el~ with keyword ~:ensure~.

#+begin_src emacs-lisp
  ;; detect native-compile feature
  (if (and (featurep 'native-compile)
           (fboundp 'native-comp-available-p)
           (native-comp-available-p))
      ;; Activate `native-compile'
      (setq native-comp-jit-compilation t
            package-native-compile t)
    ;; Deactivate the `native-compile' feature if it is not available
    (setq features (delq 'native-compile features)))

  ;; pick up a fast ELPA mirror for package.el
  (custom-set-variables
   '(package-archives
     '(;; GNU ELPA (default)
       ;; ("gnu"    . "https://elpa.gnu.org/packages/")
       ;; ("nongnu" . "https://elpa.nongnu.org/nongnu/")
       ;; ("melpa"  . "https://melpa.org/packages/")
       ;; TUNA mirrors (for China Mainland)
       ("gnu"   . "https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
       ("nongnu" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/")
       ("melpa" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
       ;; ("org" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/org/")
       ))
   )
#+end_src

To accelerate emacs startup we can do:
1. pacakge quickstart. This feature is provided after emacs 27, which supports compile all loaddefs into one single ~package-quickstart.el~ to avoid openning too much loaddef files. This is enabled in [[file:init.el][init.el]].
2. lazy loading. This feature can be enabled automatically by setting ~use-package-deferring-keywords~, all configurations with these keywords present will be deferred by default.

Emacs has a severe performance problem when ~load-path~ is a large list, discussed in Emacs bug#41646 and finally solved by adding a cache-based filter for ~load~ in Emacs 31. Before that, the only way to resolve this problem is to explicitly set file path for ~require~, and the path can only be detected automatically on compilation (otherwise we must code them), this is never implemented in koishimacs, because compilation usually brings more problems.

#+begin_src emacs-lisp
  (use-package use-package
    :preface
    (defvar use-package-selected-packages nil
      "Packages pulled in by use-package.")

    (defvar use-package-vc-selected-packages nil
      "Packages pulled in by use-package-vc.")

    :init
    (define-advice use-package-handler/:ensure
        (:around (fn name keyword args rest state))
      (dolist (ensure args)
        (let ((package
               (or (and (eq ensure t)
                        (use-package-as-symbol name))
                   ensure)))
          (when package
            (when (consp package)
              (setq package (car package)))
            (add-to-list 'use-package-selected-packages package))))
      (funcall fn name keyword args rest state))

    (define-advice use-package-handler/:vc
        (:around (fn name keyword args rest state))
      (add-to-list 'use-package-vc-selected-packages
                   (cons (car args) (cadr args)))
      (add-to-list 'use-package-selected-packages (car args))
      (funcall fn name keyword args rest state))

    (defun my:one-off-hook (hook function)
      "Trigger FUNCTION only once on HOOK, then remove it."
      (let ((fname (gensym "my:one-off-hook-")))
        (eval
         `(add-hook ',hook
                    (defun ,fname ()
                      (,function)
                      (remove-hook ',hook ',fname))))))

    (defun my:advice-one-off (symbol how function &optional props)
      "Add an one-off advice FUNCTION to SYMBOL, then remove it.
  See description of HOW and PROPS in document of `advice-add'."
      (let ((fname (gensym "my:one-off-advice-")))
        (eval
         `(advice-add ,symbol ,how
                      (defun ,fname ()
                        (,function)
                        (advice-remove ',symbol ',fname))
                      ,props))))

    (defun use-package-handler/:one-off-hook (name _keyword args rest state)
      "Handler for the `:one-off-hook` keyword in `use-package'."
      (use-package-concat
       (use-package-process-keywords name rest state)
       (cl-mapcan
        #'(lambda (def)
            (let ((syms (car def))
                  (fun (cdr def)))
              (when fun
                (mapcar
                 #'(lambda (sym)
                     (let ((symname (symbol-name sym)))
                       (if (and (boundp sym)
                                ;; Mode variables are usually bound, but
                                ;; their hooks are named FOO-mode-hook.
                                (not (string-suffix-p "-mode" symname)))
                           `(my:one-off-hook ',sym #',fun)
                         `(my:one-off-hook
                           ',(intern (concat symname use-package-hook-name-suffix))
                           #',fun))))
                 (use-package-hook-handler-normalize-mode-symbols syms)))))
        (use-package-normalize-commands args))))

    (setq use-package-keywords (cons ':one-off-hook use-package-keywords))
    (defalias 'use-package-normalize/:one-off-hook 'use-package-normalize/:hook)
    :custom
    (use-package-always-defer t)
    (use-package-vc-prefer-newest t)
    ;; set up this to get package loading statistics
    (use-package-compute-statistics t)
    )
#+end_src

With package ~async~ we can use ~async-byte-recompile-directory~ for asynchronous byte-compiling.

#+begin_src emacs-lisp
  (use-package async
    :ensure t
    :init
    (defun my:byte-compile-subdirs-async (dir)
      "Byte compile all subdirectories under DIR asynchronously."
      (interactive "DPath of parent directory: ")
      (dolist (file (file-name-all-completions "" dir))
        (when (and (directory-name-p file)
                   (not (member file '("./" "../" ".git/" "archives/" "gnupg/"))))
          (async-byte-recompile-directory
           (concat (file-name-as-directory dir) file)))))

    (async-bytecomp-package-mode)
    )
#+end_src

** hook decorators
Originally I mount a lot of minor modes on ~prog-mode-hook~, however, this may break elisp bytecompile on bootstraping. So I decided to add decorators to such hooks to avoid direct binding to it.

#+begin_src emacs-lisp
  (defvar my/hook-decorators nil
    "A alist of hook decorators, items in (HOOK-NAME . LOADER).")

  (defun my:define-hook-decorator (mode &optional file loader)
    "Define a hook decorator for given name MODE.
  FILE is used for `with-eval-after-load' to ensure MODE is bound, default
  value is MODE.  You may also provide a customized LOADER for loading
  my/MODE-hook."
    (unless (symbolp mode)
      (error "%s is not a symbol!" mode))
    (let ((decorator
           (intern (concat "my/" (symbol-name mode) "-hook")))
          (docstring
           (concat "Hook decorator for `" (symbol-name mode) "'.")))
      ;; define a variable for it using `defvar'
      (eval `(defvar ,decorator nil ,docstring))
      (let ((orig
             (intern (concat (symbol-name mode) "-hook")))
            (file (or file mode)))
        ;; set a loader for that hook decorator
        (setf (alist-get decorator my/hook-decorators)
              (if (and loader (functionp loader))
                  loader
                (lambda ()
                  (with-eval-after-load file
                    (add-to-list orig (lambda () (run-hooks decorator))))))))))

  (defun my:inject-hook-decorators ()
    "Inject hook decorators to those hooks to be decorated."
    (mapc (lambda (decorator) (funcall (cdr decorator)))
          my/hook-decorators))

  (my:define-hook-decorator 'prog-mode)
  (my:define-hook-decorator 'org-mode 'org)

  (add-hook 'after-init-hook #'my:inject-hook-decorators)
#+end_src

* UI
** TUI acceleration
We may avoid loading something packages that may cause problems in
terminal. However, the client configuration depends on the daemon. To make
clients available for GUI, the daemon has to be excluded. Unfortunately, we
still can not set this in ~early-init.el~

#+begin_src emacs-lisp
  (defvar my/load-gui-config-p
    (or (display-graphic-p) (daemonp))
    "Indicates whether GUI related config should be loaded.")

  (defvar my/be-iconic-p t
    "Indicates whether use unicode icons.
  Currently we do not have a good way to detect if they're supported.")
#+end_src

** color scheme
A beautiful color scheme is necessary for everyone's eyes.

#+begin_src emacs-lisp
  (use-package koishi-theme
    :ensure t
    :init
    ;; load a sweet color theme
    ;; currently koishi-theme is not suit for 8-color terminal
    (when (or (daemonp)
              (>= (display-color-cells) 256))
      (load-theme 'koishi))
    ;; background transparency in TUI mode
    (unless my/load-gui-config-p
      (setf (alist-get 'background-color default-frame-alist) nil))
    )
#+end_src

** initialization
Setup GUI. We can set the initial X window size and position. It is a pity that the han font can not be scaled once the size is fixed. To solve the problem, we can only set specific font face when width alignment is needed.

#+begin_src emacs-lisp
  (defun my:map-set-fontset-font (&rest arglist)
    "A helper for setup fontsets, ARGLIST is a list of args for `set-fontset-font'."
    (dolist (args arglist)
      (condition-case nil
          (apply #'set-fontset-font args)
        (error (message "failed to apply set-fontset-font to %S" args)))))

  (defun my:map-set-face-attribute (&rest arglist)
    "A helper for run `set-face-attributes' across given ARGLIST."
    (dolist (args arglist)
      (condition-case nil
          (apply #'set-face-attribute args)
        (error (message "failed to apply set-face-attribute to %S" args)))))

  (defun my:setup-fontset ()
    (my:map-set-fontset-font
     '(t han "LXGW Wenkai Mono")
     '(t kana "LXGW Wenkai Mono")
     '(t nil "Symbols Nerd Font Mono" nil append)
     ))

  (when my/load-gui-config-p
    ;; set fonts
    (my:setup-fontset)
    ;; set faces
    (my:map-set-face-attribute
     '(default nil :family "DejaVu Sans Mono" :slant normal :weight regular :height 128)
     '(fixed-pitch nil :family "DejaVu Sans Mono" :slant normal :weight regular :height 128)
     '(fixed-pitch-serif nil :family "FreeMono" :weight bold :height 136)
     '(variable-pitch nil :family "DejaVu Serif" :height 136)
     )
    ;; set default frame title
    (setq-default frame-title-format
                  (concat "KoishiMACs   üëÅÔ∏è   %b   üñåÔ∏è   " (user-login-name) "@" (system-name)))
    ;; set transparent window for emacs 29+
    (add-to-list 'default-frame-alist '(alpha-background . 80))
    )

  ;; resize initial window when in GUI but not a client
  (when (display-graphic-p)
    ;; set transparent window for emacs 29+
    (set-frame-parameter (selected-frame) 'alpha-background 80)
    ;; (set-frame-position (selected-frame) 60 60)
    (set-frame-size (selected-frame) 120 40)
    ;; toggle pixel scrolling
    (pixel-scroll-precision-mode)
    )

#+end_src

Setup for server edit: always create a new frame, delete frame when done.

#+begin_src emacs-lisp
  (when (daemonp)
    ;; set fontset for server
    (add-hook 'server-after-make-frame-hook #'my:setup-fontset)

    ;; always create new frame
    (add-hook
     'server-switch-hook
     #'(lambda ()
         (let ((server-buf (current-buffer)))
           (bury-buffer)
           (if server-buffer-clients
               (switch-to-buffer-other-frame server-buf)
             (switch-to-buffer server-buf)))))

    (custom-set-variables '(server-kill-new-buffers t))
    (global-set-key (kbd "C-x C-c") (kbd "C-x # C-x 5 0"))
    ;; resize initial window
    (setf (alist-get 'width default-frame-alist) 100
          (alist-get 'height default-frame-alist) 45
          )
    )
#+end_src

Terminal mode configuration, actually there are very little we can do to the emacsclient. Just assume that clients are all graphic frames.

#+begin_src emacs-lisp
  (unless my/load-gui-config-p
    ;; don't display menu bar
    (menu-bar-mode -1)
    ;; enable mouse navigation if supported
    (xterm-mouse-mode)
    ;; fix arrow keys in some terminals
    (defvar arrow-keys-map (make-sparse-keymap)
      "Keymap for arrow keys.")

    (bind-keys
     :map arrow-keys-map
     ("A" [up])
     ("B" [down])
     ("C" [right])
     ("D" [left]))
    ;; arrow keys may be broken in some terminals,
    ;; define a wrapper to translate ESC [ or ESC O
    (define-key esc-map "[" arrow-keys-map)
    (define-key esc-map "O" arrow-keys-map)
    )
#+end_src

** be iconic.
~diminish~ can replace minor mode lighters in modeline. It has a keyword integration in ~use-package~ but not part of Emacs, so we need to patch ~use-package~ if it is not available.

#+begin_src emacs-lisp
  (use-package diminish :ensure t :defer nil)

  ;; if diminish is not available, patch the keyword
  (when (not (featurep 'diminish))
    (define-advice use-package-handler/:diminish
        (:around (orig-fun &rest args))
      (use-package-process-keywords
        (car args) (nth 4 args) (nth 5 args))))
#+end_src

~nerd-icons~ provides an awesome icon pack.
#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t
    :defer nil
    :when my/be-iconic-p
    )

  (use-package nerd-icons-completion
    :ensure t
    :when my/be-iconic-p
    :config
    (nerd-icons-completion-mode)
    :hook
    (marginalia-mode . nerd-icons-completion-marginalia-setup)
    )

  (use-package nerd-icons-ibuffer
    :ensure t
    :when my/be-iconic-p
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode)
    )
#+end_src

** modeline
~doom-modeline~ is the coolest one. However, doom modeline's framework seems to be too heavy for me. So, finally I decided to create a simpler modeline only for koishimacs, named ~violet-line~ for it is colored purple.

#+begin_src emacs-lisp
  ;; violet-line
  (defun violet-line--shrink-path (path &optional max-pixel-width)
    (let ((max-pixel-width (or max-pixel-width 600)))
      (if (< (string-pixel-width path) max-pixel-width)
          path
        (let* ((comp (file-name-split path))
               (base (car (last comp)))
               (dirs (cl-remove-if #'string-empty-p (butlast comp)))
               (shrinked-dirs (mapconcat (lambda (dir)
                                           (substring dir 0 1))
                                         dirs "/"))
               (shrinked-path (concat shrinked-dirs "/" base)))
          (if (< (string-pixel-width shrinked-path) max-pixel-width)
              shrinked-path
            (if (< (string-pixel-width base) max-pixel-width)
                base
              (let* ((space-pixel-width (string-pixel-width " "))
                     (len (floor (/ max-pixel-width space-pixel-width))))
                (if (> len 0)
                    (concat (substring base 0 len) "...")
                  ""))))))))

  (defvar-local violet-line-buffer-icon
      `(:eval
        (when my/be-iconic-p
          (if-let ((s (buffer-file-name)))
              (nerd-icons-icon-for-file s)
            (nerd-icons-icon-for-buffer))))
    )
  (put 'violet-line-buffer-icon 'risky-local-variable t)

  (defvar-local violet-line-buffer-identification
      `(:eval
        (propertize
         (let ((max-pixel-width
                (- (window-pixel-width)
                   (string-pixel-width
                    (format-mode-line
                     ;; do not cause recursion
                     (delete 'mode-line-format-right-align
                             (remove 'violet-line-buffer-identification
                                     mode-line-format)))))))
           (violet-line--shrink-path
            (if-let ((s (buffer-file-name)))
                (abbreviate-file-name s)
              (buffer-name))
            max-pixel-width))
         'face 'mode-line-buffer-id
         'help-echo (purecopy "Buffer name\n\
  mouse-1: Previous buffer\n\
  mouse-3: Next buffer")
         'mouse-face 'mode-line-highlight
         'local-map mode-line-buffer-identification-keymap))
    )
  (put 'violet-line-buffer-identification 'risky-local-variable t)

  (defvar-local violet-line-position
      `((:propertize
         ("" mode-line-percent-position)
         local-map ,mode-line-column-line-number-mode-map
         mouse-face mode-line-highlight
         help-echo "Window Scroll Percentage
  mouse-1: Display Line and Column Mode Menu")
        (size-indication-mode
         ,(propertize
         "/%I"
         'local-map mode-line-column-line-number-mode-map
         'mouse-face 'mode-line-highlight
         'help-echo "Size indication mode\n\
  mouse-1: Display Line and Column Mode Menu"))
        ;; column and line number display, leave them unchanged
        ,(assoc 'line-number-mode mode-line-position)
        )
    )
  (put 'violet-line-position 'risky-local-variable t)

  (defface violet-line-emphasis-1
    `((t (:foreground
          ,(if (bound-and-true-p koishi-theme-light) "#523" "#ADC")
          :weight bold)))
    "A custom face for violet-line segment display.")

  (defvar-local violet-line-modes
      (let ((recursive-edit-help-echo
             "Recursive edit, type C-M-c to get out"))
        (list (propertize "%[" 'help-echo recursive-edit-help-echo)
              `(:propertize ("" mode-name)
                            face violet-line-emphasis-1
                            help-echo "Major mode\n\
  mouse-1: Display major mode menu\n\
  mouse-2: Show help for major mode\n\
  mouse-3: Toggle minor modes"
                            mouse-face mode-line-highlight
                            local-map ,mode-line-major-mode-keymap)
              '("" mode-line-process)
              `(:propertize ("" minor-mode-alist)
                            mouse-face mode-line-highlight
                            help-echo "Minor mode\n\
  mouse-1: Display minor mode menu\n\
  mouse-2: Show help for minor mode\n\
  mouse-3: Toggle minor modes"
                            local-map ,mode-line-minor-mode-keymap)
              (propertize "%n" 'help-echo "mouse-2: Remove narrowing from buffer"
                          'mouse-face 'mode-line-highlight
                          'local-map (make-mode-line-mouse-map
                                      'mouse-2 #'mode-line-widen))
              (propertize "%]" 'help-echo recursive-edit-help-echo)
              " "))
    )
  (put 'violet-line-modes 'risky-local-variable t)

  ;; for right-aligned components
  (setq mode-line-right-align-edge 'right-fringe)

  ;; make use of native mode-line components defined in bindings.el
  (setq-default mode-line-format
                `("%e"
                  mode-line-front-space
                  (:propertize
                   (""
                    ,mode-line-mule-info
                    ,mode-line-client
                    ,mode-line-modified
                    ,mode-line-remote
                    ,mode-line-window-dedicated)
                   face mode-line-emphasis
                   display (min-width (6.0)))
                  mode-line-frame-identification
                  violet-line-buffer-icon
                  violet-line-buffer-identification
                  "   "
                  violet-line-position
                  (project-mode-line project-mode-line-format)
                  (vc-mode vc-mode)
                  mode-line-format-right-align
                  "  "
                  violet-line-modes
                  mode-line-misc-info
                  mode-line-end-spaces
                  ))
#+end_src

Other useful components:

#+begin_src emacs-lisp
  (use-package hide-mode-line
    :ensure t
    :bind
    ("M-M" . hide-mode-line-mode)
    )

  (use-package keycast
    :ensure t
    :custom-face
    (keycast-key ((t (:inherit (mode-line) :box (:line-width 2 :color "#C0A363" :style released-button)))))
    :custom
    (keycast-mode-line-format "%1s%k%r")
    (keycast-mode-line-remove-tail-elements nil)
    (keycast-mode-line-insert-after 'mode-line-modes)
    )
#+end_src

** completion
Emacs use minibuffer for quick interactions, most interactions can be accelerated by a powerful completion framework.

- ~vertico~ provides a performant and minimalist vertical completion UI
- ~consult~ provides search and navigation commands
- ~embark~ provides a unified action to access to actions (commands) relevant to the target around point.

Actually, this framework is too powerful and there has be a lot of extensions. I will just use some basic features it seems to have. As for other functions, we have other packages that aims to do it.

Here we replace the ~C-s~ keybinding with ~consult-line~, although its behavior differs from ~isearch-forward~, I found that replacing this keybinding indeed accelerated my daily usage.

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :defer nil
    :config
    (orderless-define-completion-style orderless+initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    (setq completion-category-overrides
          '((file (styles partial-completion orderless+initialism))
            (buffer (styles orderless+initialism))
            (consult-multi (styles orderless+initialism))
            (command (styles orderless+initialism))
            (variable (styles orderless+initialism))
            (symbol (styles orderless+initialism))))
    :custom
    (completion-styles '(orderless basic substring partial-completion flex))
    (orderless-matching-styles '(orderless-literal orderless-regexp))
    )

  (use-package vertico
    :ensure t
    :diminish
    ((vertico-mode . " Û∞ÑÑ")
     (vertico-multiform-mode . " Û∞õ°"))
    :custom
    (vertico-scroll-margin 0) ;; Different scroll margin
    (vertico-count 20) ;; Show more candidates
    (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode)
    (setq vertico-multiform-commands
          '((consult-imenu buffer indexed)
            (consult-flycheck buffer indexed)
            (consult-yank-pop indexed)
            ))
    (setq vertico-multiform-categories
          '((embark-keybinding grid)
            (consult-grep buffer)
            (org-roam-node-find buffer indexed)
            ))
    (vertico-multiform-mode)

    :bind
    (:map vertico-map
          ("M-j" . vertico-quick-jump)
          ("M-?" . embark-bindings)      ;; do not override '?'
          )
    )

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :ensure t
    :init (savehist-mode)
    )

  (use-package emacs
    :custom
    ;; Enable context menu. `vertico-multiform-mode' adds a menu in the minibuffer
    ;; to switch display modes.
    (context-menu-mode t)
    ;; Support opening new minibuffers from inside existing minibuffers.
    (enable-recursive-minibuffers t)
    ;; Do not allow the cursor in the minibuffer prompt
    (minibuffer-prompt-properties
     '(read-only t cursor-intangible t face minibuffer-prompt))
    ;; Emacs 28 and newer: Hide commands in M-x which do not work in the current
    ;; mode.  Vertico commands are hidden in normal buffers. This setting is
    ;; useful beyond Vertico.
    (read-extended-command-predicate #'command-completion-default-include-p)
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (when (< emacs-major-version 31)
      (define-advice completing-read-multiple
          (:filter-args (args) crm-indicator)
        (cons (format "[CRM%s] %s"
                      (replace-regexp-in-string
                       "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                       crm-separator)
                      (car args))
              (cdr args))))
    )

  (use-package marginalia
    :ensure t
    :init (marginalia-mode)
    )

  (use-package consult
    :ensure t
    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Avoid fontify lagging problem [[https://github.com/minad/consult/issues/329]]
    (setq consult-fontify-max-size 65536)

    :config
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     :preview-key '(:debounce 0.4 any)
     consult-bookmark consult-recent-file consult-xref
     consult-source-bookmark consult-source-file-register
     consult-source-recent-file consult-source-project-recent-file
     :preview-key '("S-<down>" "S-<up>"))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; define a thing-at-point search function
    (defalias 'consult-line-thing-at-point 'consult-line)
    (consult-customize
     consult-line-thing-at-point
     :initial (thing-at-point 'symbol))

    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args)))

    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ("C-c r" . consult-register)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b"   . consult-buffer)              ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s ." . consult-line-thing-at-point)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ("M-s s" . consult-line)                  ;; for less finger motion
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s s" . consult-line)                  ;; for less finger motion
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           )

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)
    )

  (use-package consult-flycheck
    :ensure t
    :bind ("M-g f" . consult-flycheck)              ;; Alternative: consult-flymake
    )

  (use-package consult-eglot
    :ensure t
    :bind
    (:map eglot-mode-map
          ([remap xref-find-apropos] . consult-eglot-symbols))
    )

  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("M-." . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
    :autoload (embark-prefix-help-command)
    :init
    (setq prefix-help-command #'embark-prefix-help-command)
    (setq embark-indicators
          '(embark-mixed-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))
    (setq embark-help-key "?")
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))
    )

  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode)
    )

#+end_src

** window manager
Except for minibuffer, we usually use interactive buffers for more complicated interactions. Another solution may be introduced to manage all such buffers, e. g. vterm, ibuffer, message, etc.

~popwin~ provides more agile workflows based on popup buffers.
Related packages that provides auxiliary functions must be placed before it.

Since ~embark~ already has an ~embark-export~ that makes use of ~occur-mode~, we won't add ~occur-mode~ to ~popwin:special-display-config~ .

#+begin_src emacs-lisp
  (use-package popwin
    :ensure t
    :autoload (popwin:popup-buffer
               popwin:get-buffer
               popwin:stick-popup-window
               popwin:close-popup-window
               )
    :preface
    (defmacro my:popwin:create (name body)
      `(let ((buf-name ,name))
         (unless (buffer-live-p buf-name)
           ,body
           (switch-to-prev-buffer))
         (popwin:popup-buffer
          (popwin:get-buffer buf-name :create))))

    (defmacro my:popwin:toggle (name creator)
      `(if (get-buffer-window ,name (selected-frame))
           (popwin:close-popup-window)
         (progn
           ,creator
           (popwin:stick-popup-window))))

    :init
    ;; enable popwin mode
    (popwin-mode)

    (defun my:popwin:scratch ()
      "Show *scratch* in a popwin, if not exist, create it."
      (interactive)
      (popwin:popup-buffer (get-scratch-buffer-create)))

    (defun my:popwin:scratch-toggle ()
      "Toggle *scratch* buffer as a popwin."
      (interactive)
      (my:popwin:toggle "*scratch*"
                        (my:popwin:scratch)))

    :config
    ;; special display config
    (mapc
     (lambda (conf) (add-to-list 'popwin:special-display-config conf))
     '(("*Macroexpansion*" :noselect t)
       ("*Pp Macroexpand Output*" :noselect t)
       ("*Pp Eval Output*" :noselect t)))

    :bind-keymap
    ("C-z" . popwin:keymap)
    :bind
    (:map popwin:keymap
          ("C-z" . suspend-emacs)
          ("c" . my:popwin:scratch))
    )

  (use-package vterm
    :ensure t
    :commands (vterm)
    :autoload (vterm-send-string
               vterm-send-return)
    :init
    (setq vterm-buffer-name "*vterm*")

    (defun my:vterm--buffer-name (&optional arg)
      (cond ((numberp arg)
             (format "%s<%d>" vterm-buffer-name arg))
            ((stringp arg)
             arg)
            (t
             vterm-buffer-name)))

    (defun my:popwin:vterm (&optional arg)
      "Run vterm in a popwin. ARG is passed to vterm."
      (interactive "P")
      (my:popwin:create (my:vterm--buffer-name arg)
                        (vterm arg)))

    (defun my:popwin:vterm-toggle (&optional arg)
      "Toggle vterm buffer as a popwin."
      (interactive "P")
      (my:popwin:toggle (my:vterm--buffer-name arg)
                        (my:popwin:vterm arg)))
    :bind
    (("C-`" . my:popwin:vterm-toggle)
     :map popwin:keymap
     ("x" . my:popwin:vterm))
    )

  (use-package ibuffer
    :commands (ibuffer)
    :init
    (defun my:popwin:ibuffer ()
      "Show *Ibuffer* in a popwin, if not exist, create it."
      (interactive)
      (popwin:popup-buffer
       (popwin:get-buffer "*Ibuffer*" :create))
      (ibuffer))
    :bind
    (:map popwin:keymap
          ("b" . my:popwin:ibuffer))
    )
#+end_src

** sideline
Sideline is useful to display information related to current line.

#+begin_src emacs-lisp
  (use-package sideline
    :ensure t
    :diminish (sideline-mode . " Û±Åë")
    :init
    (setq
     sideline-backends-left-skip-current-line t
     sideline-backends-right-skip-current-line t
     sideline-order-left 'down
     sideline-order-right 'up
     sideline-format-left "%s   "
     sideline-format-right "   %s"
     sideline-priority 100
     sideline-display-backend-name t
     )
    :hook
    ((flycheck-mode eglot-mode) . sideline-mode)
    )

  (use-package sideline-eglot
    :ensure t
    :init
    (setq sideline-backends-left '(sideline-eglot))
    )

  (use-package sideline-flycheck
    :ensure t
    :init
    (setq sideline-backends-right '(sideline-flycheck))
    :hook (flycheck-mode . sideline-flycheck-setup)
    )
#+end_src

** other widgets
These are my collection, but not that important, or not used.

#+begin_src emacs-lisp
  ;; an alternative tab bar
  (use-package centaur-tabs
    :ensure t
    :when my/load-gui-config-p
    :custom
    (centaur-tabs-set-icons t)
    (centaur-tabs-style "wave")
    (centaur-tabs-set-bar 'under)
    (x-underline-at-descent-line t)
    (centaur-tabs-enable-key-bindings t)
    :config
    (centaur-tabs-headline-match)
    :bind
    ("C-<next>"  . centaur-tabs-forward)
    ("C-<prior>" . centaur-tabs-backward)
    ("C-S-<next>"  . centaur-tabs-forward-group)
    ("C-S-<prior>" . centaur-tabs-backward-group)
    )

  ;; a fake mini code scroll map, with bad efficiency
  (use-package minimap
    :ensure t
    :when my/load-gui-config-p
    )

  ;; just something fun
  (use-package power-mode
    :ensure t
    :when my/load-gui-config-p
    :diminish " Û∞ü©"
    :custom
    (power-mode-streak-shake-threshold nil)
    )

#+end_src

** dashboard
A big but useless thing.

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :when (display-graphic-p)
    :preface
    ;; because these packages are placed later,
    ;; we have to specify these autoloads here.
    (autoload #'org-agenda "org-agenda")
    (autoload #'elfeed "elfeed")
    (autoload #'gnus "gnus")
    :init
    (dashboard-setup-startup-hook)
    :custom-face
    (dashboard-banner-logo-title ((t (:inherit italic :height 1.5 :family "Chopin Script"))))
    :custom
    (dashboard-banner-logo-title "Wish Outspeak  Without speak")
    (dashboard-buffer-last-width 80)
    (dashboard-center-content    t)
    (dashboard-footer-messages
     '("Representation \"All Ancestors Standing Beside Your Bed\""
       "Representation \"Danmaku Paranoia\""
       "Instinct \"Release of ID\""
       "Suppression \"Super Ego\""
       "Response \"Youkai Polygraph\""
       "Unconscious \"Rorschach in Danmaku\""
       "Rekindled \"The Embers of Love\""
       "Depths \"Genetics of the Unconscious\""
       "Philosophy of the Despised"
       "Subterranean Rose"
       )
     )
    (dashboard-image-banner-max-height 400)
    (dashboard-init-info
     (lambda () (format "GNU Emacs %s started in %s"
                    emacs-version (emacs-init-time))))
    (dashboard-startupify-list
     '(dashboard-insert-banner
       dashboard-insert-newline
       dashboard-insert-banner-title
       dashboard-insert-newline
       dashboard-insert-navigator
       dashboard-insert-newline
       dashboard-insert-init-info
       dashboard-insert-newline
       dashboard-insert-newline
       dashboard-insert-footer))
    (dashboard-navigator-buttons
     '((("ÔÅ≥ " "Agenda" "Task for this week"
         (lambda (&rest _) (org-agenda-list))
         warning "[" "]")
        ("ÔÇû " "Elfeed" "Browse RSS Feeds"
         (lambda (&rest _) (elfeed))
         warning "[" "]")
        ("Ôá™ " "Gnus" "Browse News & Mails"
         (lambda (&rest _) (gnus))
         warning "[" "]")
        ("Óäé " "Butterfly" "Real world programming!"
         (lambda (&rest _) (butterfly))
         warning "[" "]")
        )
       )
     )
    (dashboard-set-file-icons    t)
    (dashboard-set-heading-icons t)
    (dashboard-set-init-info     t)
    (dashboard-set-navigator     t)
    (dashboard-image-extra-props '(:mask heuristic))
    (dashboard-startup-banner
     (my:weak-path (file-name-concat
                    user-emacs-directory "icons/koishimacs-logo.svg")))
    :bind
    (:map dashboard-mode-map
          ("a" . org-agenda)
          ("b" . butterfly)
          ("f" . elfeed)
          ("n" . gnus)
          )
    )
#+end_src

* Text Editor
** navigation
A hacker can fly across lines and frames.

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind
    ("M-<tab>" . ace-window)  ;; left hand
    ("M-o"     . ace-window)  ;; right hand
    )

  (use-package ace-link
    :ensure t
    :init
    (ace-link-setup-default)
    )

  (use-package avy
    :ensure t
    :bind
    ;; M-g bindings in `goto-map'
    ("M-g f" . avy-goto-char)
    ("M-g v" . avy-goto-char-2)
    ("M-g l" . avy-goto-line)
    ("M-g w" . avy-goto-word-0)
    ("M-g e" . avy-goto-word-1)
    )

  (use-package windmove
    :init
    (windmove-mode)
    :custom
    (windmove-allow-all-windows t)
    (windmove-default-keybindings '([ignore] meta))
    (windmove-swap-states-default-keybindings '([ignore] meta shift))
    (windmove-wrap-around nil)
    )

  (use-package windower
    :ensure t
    :autoload (windower-toggle-single
               windower-toggle-split)
    :bind
    (("M-1" . windower-toggle-single)
     ("M-2" . windower-toggle-split)
     ("C-S-<left>"  . windower-move-border-left)
     ("C-S-<right>" . windower-move-border-right)
     ("C-S-<up>"    . windower-move-border-above)
     ("C-S-<down>"  . windower-move-border-below)
     )
    )

  (use-package winner
    :init
    (winner-mode)
    )
#+end_src

** visualization
More previews and visual feedback.

#+begin_src emacs-lisp
  (use-package simple
    :diminish (visual-line-mode . " Û∞¥ê")
    :hook (my/org-mode . visual-line-mode)
    :bind
    ("C-c v l" . visual-line-mode)
    )

  (use-package visual-fill-column
    :ensure t
    :custom
    (visual-fill-column-center-text t)
    :bind
    ("C-c v f" . visual-fill-column-mode)
    ("C-c v c" . visual-fill-column-toggle-center-text)
    )

  (use-package visual-regexp
    :ensure t
    :bind
    ([remap query-replace-regexp] . vr/query-replace)
    ("C-c M-%" . vr/mc-mark)
    )

  (use-package vundo
    :ensure t
    :bind
    ("C-c C-/" . vundo)
    )

  ;; view large file
  (use-package vlf
    :ensure t
    :init
    (require 'vlf-setup)
    :custom
    (vlf-application 'dont-ask)
    )

#+end_src

** snippet
Writing with templates.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish (yas-minor-mode . " Û∞∞≥")
    :hook ((my/org-mode my/prog-mode) . yas-minor-mode)
    :defines yas-minor-mode-map
    )

  (use-package yasnippet-snippets
    :ensure t
    :after yasnippet
    )

  (use-package auto-yasnippet
    :ensure t
    :after yasnippet
    :bind
    (:map yas-minor-mode-map
          :prefix-map aya-command-map
          :prefix "C-'"
          ("w" . aya-create)
          ("TAB" . aya-expand)
          ("SPC" . aya-expand-from-history)
          ("d" . aya-delete-from-history)
          ("c" . aya-clear-history)
          ("n" . aya-next-in-history)
          ("p" . aya-previous-in-history)
          ("s" . aya-persist-snippet)
          ("o" . aya-open-line)
          ;; yasnippet commands bind to prefix C-c &
          ("C-s" . yas-insert-snippet)
          ("C-v" . yas-visit-snippet-file)
          ("C-n" . yas-new-snippet)
          )
    )
#+end_src

** structural edit
Edit text as structural data.

#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish (smartparens-mode . " Û±Éó")
    :init
    (require 'smartparens-config)

    (defun my:kill-ring-save ()
      "Copy region with noselect action -- save current sexp."
      (interactive)
      (if (region-active-p)
          (call-interactively #'kill-ring-save)
        (call-interactively #'sp-copy-sexp)))

    (defun my:kill-region ()
      "Kill region with noselect action -- kill current sexp."
      (interactive)
      (if (region-active-p)
          (call-interactively #'kill-region)
        (call-interactively #'sp-kill-sexp)))
    :bind
    ;; there are already in `esc-map', with ESC C- compose
    ;; or C-M- compose
    ([remap forward-sexp] . sp-forward-sexp)
    ([remap backward-sexp] . sp-backward-sexp)
    ([remap up-list] . sp-up-sexp)
    ([remap down-list] . sp-down-sexp)
    ([remap kill-sexp] . sp-kill-sexp)
    ([remap transpose-sexps] . sp-transpose-sexp)
    ;; with ESC- M- compose
    ("ESC M-o" . sp-split-sexp)  ;; (a b) -> (a) (b)
    ("ESC M-^" . sp-join-sexp)   ;; (a) (b) -> (a b)
    ;; or simply M-S- compose
    ("M-<backspace>" . sp-unwrap-sexp) ;; (a) -> a
    ("M-(" . sp-wrap-round)            ;; a -> (a)
    ("M-)" . sp-rewrap-sexp)   ;; (a b) -> [a b]
    ;; add default behavior for C-w and M-w
    ("C-w" . my:kill-region)
    ("M-w" . my:kill-ring-save)
    :hook
    (my/prog-mode . smartparens-mode)
    )

  (use-package multiple-cursors
    :ensure t
    :diminish (multiple-cursors-mode . " Û∞óß")
    :bind
    ("C->" . mc/mark-next-like-this)
    ("C-<" . mc/mark-all-dwim)
    ("C-S-<mouse-1>" . mc/add-cursor-on-click)
    )

  ;; multi-point edit
  (use-package iedit
    :ensure t
    :diminish (iedit-mode . " Û±¢ì")
    :bind ("C-;" . iedit-mode)
    )

  ;; indirect edit everywhere
  (use-package separedit
    :ensure t
    :commands (separedit)
    :bind
    (:map prog-mode-map
     ("C-c '" . separedit)
     :map minibuffer-local-map
     ("C-c '" . separedit)
     :map help-mode-map
     ("C-c '" . separedit)
     )
    )

  ;; fold code blocks
  (use-package hideshow
    :ensure t
    :diminish (hs-minor-mode . " Û∞Æï")
    :hook (my/prog-mode . hs-minor-mode)
    )

#+end_src

** other tools
Not classified yet.

#+begin_src emacs-lisp
  (use-package pyim
    :ensure t
    :custom
    (default-input-method "pyim")
    (pyim-cloudim 'baidu)
    )

  ;; Conflict-free Replicated Data Types
  ;; provides collaborative editing support
  (use-package crdt :ensure t)

#+end_src

* Emacs IDE
** completion at point
Although there are many other code completion frontends today, ~company~ is still the most stable one.

By default ~company~ uses overlay for display completion options, which has a series of problems. These is a package ~company-box~ which uses child frames, but has some performance problems with documentation display. So, as a tradeoff, currently I don't use child frames and just stay with overlays.

#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :defines (company-mode-map
              company-active-map
              company-prefix-map
              company-backends
              company-lighter-base
              )
    :preface
    (defvar my/company-base-backends
      '(company-capf company-files company-yasnippet))

    (defvar my/company-cascade-table
      '(((c-mode c++-mode) . (company-clang company-semantic company-cmake))
        (prog-mode . (company-dabbrev-code company-gtags company-etags company-keywords))
        (text-mode . (company-dabbrev company-ispell))
        ))

    (defun my:polymeric-company-backends (backends)
      (cl-loop
       for backend in backends
       for pos = (cl-position ':with backend)
       if pos
       append (cl-subseq backend 0 pos) into ctx-aware
       and append (cl-subseq backend (1+ pos)) into ctx-agnostic
       else
       append (cl-subseq backend 0) into ctx-aware
       finally return
       (cl-remove-duplicates
        (append ctx-aware (when ctx-agnostic '(:with)) ctx-agnostic))))

    (defun my:select-company-backends ()
      (let ((selected
             (cons
              my/company-base-backends
              (mapcan
               (lambda (cs)
                 (when (derived-mode-p (car cs))
                   (list (cdr cs))))
               my/company-cascade-table))))
        (setq-local company-backends
                    (list (my:polymeric-company-backends selected)))))

    :config
    (when my/be-iconic-p (setq company-lighter-base "Û∞ê±"))
    (when my/load-gui-config-p
      (set-face-attribute 'company-tooltip nil :inherit 'fixed-pitch))
    :custom
    (company-backends (list my/company-base-backends))
    (company-transformers '(delete-consecutive-dups
                            company-sort-by-backend-importance
                            company-sort-prefer-same-case-prefix))
    (company-dabbrev-downcase nil)
    (company-files-exclusions '(".git/"))
    (company-format-margin-function 'company-text-icons-margin)
    (company-text-icons-add-background t)
    (company-idle-delay 0.2)
    (company-selection-wrap-around t)
    (company-show-numbers t)
    (company-tooltip-align-annotations t)
    :bind
    (:map company-mode-map
          ("C-<tab>" . company-other-backend)
          ("C-:" . company-begin-backend))
    :hook
    ((my/prog-mode my/org-mode) . company-mode)
    (company-mode . my:select-company-backends)
    )

  (use-package company-quickhelp
    :ensure t
    :hook (company-mode . company-quickhelp-mode)
    )

  (use-package company-quickhelp-terminal
    :ensure t
    :unless my/load-gui-config-p
    :config
    (setq company-quickhelp-use-propertized-text nil)
    :hook (company-quickhelp-mode . company-quickhelp-terminal-mode)
    )

  ;; company-math is a dependency of company-coq, may be useful.
  (use-package company-math
    :ensure t
    :init
    (add-to-list
     'my/company-cascade-table
     '((org-mode TeX-mode) . (company-math-symbols-latex company-latex-commands)))
    )

  (use-package company-coq
    :ensure t
    :diminish company-coq-mode
    :init
    (add-to-list
     'my/company-cascade-table
     '(coq-mode . (company-coq-mode)))
    :config
    (when my/be-iconic-p (setq-local company-lighter-base "Û±ìò"))
    )

  (use-package company-maxima
    :ensure t
    :autoload (company-maxima-symbols company-maxima-libraries)
    :init
    (add-to-list
     'my/company-cascade-table
     '((maxima-mode maxima-inferior-mode)
       . (company-maxima-symbols company-maxima-libraries)))
    :hook (maxima-inferior-mode . company-mode)
    )

  (use-package company-shell
    :ensure t
    :init
    (add-to-list
     'my/company-cascade-table
     '(shell-script-mode . (company-shell company-shell-env)))
    )

  (use-package slime-company
    :ensure t
    :custom
    (slime-company-completion 'fuzzy)
    :hook
    ((slime-mode slime-repl-mode)
     . (lambda ()
         (require 'slime-company)
         (slime-company-init) ;; see issues/11
         (slime-setup '(slime-fancy slime-company))
         ;; slime-mode is a minor mode so we can't use `my:select-company-backends'
         (setq-local company-backends
                     (list '(company-slime company-dabbrev-code company-files company-yasnippet)))))
    )
#+end_src

** syntax highlights
They are FANTASTIC!!!

#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :when my/load-gui-config-p
    :diminish (diff-hl-mode . " Ó´° ")
    :commands (diff-hl-mode)
    :custom (global-diff-hl-mode t)
    :hook
    (magit-post-refresh . diff-hl-magit-post-refresh)
    )

  (use-package dimmer
    :ensure t
    :when my/load-gui-config-p
    :custom
    (dimmer-mode t)
    (dimmer-adjustment-mode :background)
    (dimmer-fraction 0.1)
    (dimmer-exclusion-regexp-list
     '("^ \\*Minibuf-[0-9]+\\*$"
       "^ \\*Echo.*\\*$"
       "^ \\*Embark Actions\\*$"))
    )

  (use-package fancy-compilation
    :ensure t
    :after compile
    :config
    (fancy-compilation-mode)
    )

  (use-package indent-bars
    :ensure t
    :config
    (require 'indent-bars-ts)           ; not needed with straight
    :custom
    ;; 2025-11-5: currently the default bar character is buggy in terminal
    (indent-bars-no-stipple-char (if my/be-iconic-p ?¬¶ ?|))
    (indent-bars-no-descend-lists t) ; no extra bars in continued func arg lists
    (indent-bars-treesit-support t)
    (indent-bars-treesit-ignore-blank-lines-types '("module"))
    :hook
    ;; This zero-delay timer trick makes use of Emacs's single stack model.
    ;; It will be loaded after all the other hooks of prog-mode are loaded.
    (my/prog-mode
     . (lambda ()
         (run-at-time
          0 nil
          (lambda (buf)
            (when (buffer-live-p buf)
              (with-current-buffer buf (indent-bars-mode))))
          (current-buffer))))
    )

  (use-package highlight-parentheses
    :ensure t
    :diminish (highlight-parentheses-mode . " Û∞µ™")
    :custom (highlight-parentheses-colors
             '("aquamarine" "yellow" "violet" "tomato" "chartreuse" "deep sky blue"))
    :hook (my/prog-mode . highlight-parentheses-mode)
    )

  (use-package paren
    :custom (show-paren-style 'mixed)
    :custom-face (show-paren-match-expression ((t (:inherit t :background "#554565"))))
    :hook (my/prog-mode . show-paren-mode)
    )

  (use-package highlight-escape-sequences
    :ensure t
    :hook (my/prog-mode . hes-mode)
    )

  (use-package rainbow-mode
    :ensure t
    :diminish " Óº¶ "
    :commands (rainbow-mode)
    :hook ((emacs-lisp-mode sgml-mode css-mode js-base-mode conf-mode nxml-mode yaml-pro-mode) . rainbow-mode)
    )

#+end_src

** syntax checker
We got two backends: flycheck and flymake. Flymake is built-in but flycheck is more powerful.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (when my/be-iconic-p
      (setq flycheck-mode-line-prefix "Û±ñâ"))
    :hook
    (my/prog-mode . flycheck-mode)
    (emacs-lisp-mode
     . (lambda ()
         (when (member (buffer-name)
                       '("*Pp Eval Output*" "*Pp Macroexpand Output*"))
           (flycheck-mode -1))))
    )

  (use-package flycheck-guile
    :ensure t
    :hook (geiser-mode . (lambda () (require 'flycheck-guile))))

  (use-package flycheck-pkg-config
    :ensure t
    :after (:all flycheck cc-mode)
    :bind
    (:map flycheck-command-map
          ("@" . flycheck-pkg-config))
    )

  (use-package flymake
    :diminish (flymake-mode . " Û±ñä")
    :bind
    (:map flymake-mode-map
          ("C-x ! d" . flymake-show-buffer-diagnostics)
          ("C-x ! D" . flymake-show-project-diagnostics)
          ("C-x ! p" . flymake-goto-prev-error)
          ("C-x ! n" . flymake-goto-next-error))
    )
#+end_src

** code document
Eldoc is the bulitin code document system for emacs, it supports multiple frontends and backends.

#+begin_src emacs-lisp
  (use-package eldoc
    :diminish (eldoc-mode . " Û∞ôé")
    :init
    (defun my:popwin:eldoc ()
      (interactive)
      (popwin:popup-buffer (eldoc-doc-buffer)))

    (defun my:eldoc-follow-markdown-link ()
      (interactive)
      (eww-browse-url (get-text-property (point) 'help-echo)))

    (define-advice eldoc--format-doc-buffer
        (:after (&rest r))
      (with-current-buffer eldoc--doc-buffer
        (keymap-local-set "RET" #'my:eldoc-follow-markdown-link)))
    :bind
    (:map popwin:keymap
          ("d" . my:popwin:eldoc))
    )

  (use-package eldoc-box
    :ensure t
    :diminish eldoc-box-hover-at-point-mode
    :diminish eldoc-box-hover-mode
    :bind
    ("C-c d" . eldoc-box-help-at-point)
    )
#+end_src

** code browsing
Gnu global is much faster than ctags for emacs.

#+begin_src emacs-lisp
  (use-package gtags-mode
    :diminish " Û∞ìº"
    :ensure t
    :hook (c-mode . gtags-mode)
    )
#+end_src

** code analysis
cedet semantic mode, a sophisticated mode with LL(1) code parser framework.

I like to use it with c/c++, semantic-ia does realtime header parsing, which is really powerful. To make use of all of the IDE features provided by cedet, run ~global-ede-mode~.

Currently, ~semantic-ia~ is broken with ~treesit~, so it's disabled.

#+begin_src emacs-lisp :tangle no
  (use-package semantic
    :custom
    (semantic-idle-truncate-long-summaries nil)
    (semantic-default-submodes
     '(global-semantic-idle-scheduler-mode
       global-semanticdb-minor-mode
       global-semantic-idle-summary-mode
       global-semantic-stickyfunc-mode)
     )
    :bind
    (:map semantic-mode-map
          ("C-c , d" . semantic-ia-show-doc)
          ("C-c , v" . semantic-ia-show-variants)
          ("C-c , s" . semantic-ia-show-summary)
          ("C-," . semantic-ia-fast-jump)
          ("<C-down-mouse-1>" . semantic-ia-fast-mouse-jump)
          )
    :hook ((c-mode c++-mode) . semantic-mode)
    )
#+end_src

Emacs has introduced built-in Language Server Protocol (LSP) support since emacs29, with ~eglot~ package. This package has no extra dependencies, and provides out-of-box lsp client service.

#+begin_src emacs-lisp
  (use-package eglot
    :custom
    (eglot-stay-out-of '(company))
    :config
    ;; currently haskell-ts-mode is not supported yet
    (setf (alist-get 'haskell-ts-mode eglot-server-programs)
          '("haskell-language-server-wrapper" "--lsp"))
    :bind
    (:map eglot-mode-map
          ("C-c a" . eglot-code-actions)
          ("C-c =" . eglot-format)
          ("C-c :" . eglot-rename))
    )

  ;; a header line for hints
  (use-package breadcrumb
    :ensure t
    :hook ((my/org-mode eglot-mode) . breadcrumb-local-mode)
    )
#+end_src

Finally we get something cooler in emacs29+, treesit is merged into emacs!

Tree-sitter is a parser generator for creating *incremental* parsers, which provides us many efficient language parsers for syntactic highlighting, code alignment and navigation, etc.

Mostly following [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][this article]].

#+begin_src emacs-lisp
  (setq treesit-language-source-alist
        '((bash "https://github.com/tree-sitter/tree-sitter-bash")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
          (cmake "https://github.com/uyha/tree-sitter-cmake")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          (go "https://github.com/tree-sitter/tree-sitter-go")
          (haskell "https://github.com/tree-sitter/tree-sitter-haskell")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (java "https://github.com/tree-sitter/tree-sitter-java")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (lua "https://github.com/tree-sitter-grammars/tree-sitter-lua")
          (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
          (rust "https://github.com/tree-sitter/tree-sitter-rust")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

  (setq major-mode-remap-alist
        '((sh-mode . bash-ts-mode)
          (c-mode . c-ts-mode)
          (c++-mode . c++-ts-mode)
          (css-mode . css-ts-mode)
          (go-mode . go-ts-mode)
          (go-mod-mode . go-mod-ts-mode)
          (haskell-mode . haskell-ts-mode)
          (html-mode . html-ts-mode)
          (java-mode . java-ts-mode)
          (javascript-mode . js-ts-mode)
          (js-json-mode . json-ts-mode)
          (lua-mode . lua-ts-mode)
          (python-mode . python-ts-mode)
          (ruby-mode . ruby-ts-mode)
          (rust-mode . rust-ts-mode)))

  ;; append *-mode-hook to *-ts-mode-hook for modes in `major-mode-remap-list'
  (mapc
   #'(lambda (major-mode-remap)
       (let ((major-mode-hook
              (intern (concat (symbol-name (car major-mode-remap)) "-hook")))
             (major-ts-mode-hook
              (intern (concat (symbol-name (cdr major-mode-remap)) "-hook"))))
         (add-hook major-ts-mode-hook
                   `(lambda () (run-hooks ',major-mode-hook)))))
   major-mode-remap-alist)

  ;; We may enable some built-in treesit modes directly to be lazy
  (use-package treesit
    :custom
    (treesit-font-lock-level 4) ;; as colorful as possible
    :init
    (defun my:auto-ts-mode (language regexp &optional func)
      (add-to-list 'auto-mode-alist
                   `(,regexp . ,(or func (intern (concat (symbol-name language) "-ts-mode"))))))

    (mapc
     (lambda (conf) (apply #'my:auto-ts-mode conf))
     '((cmake "\\(?:CMakeLists\\.txt\\|\\.cmake\\)\\'")
       (yaml "\\.ya?ml\\'")
       (typescript "\\.ts\\'")
       (typescript "\\.tsx\\'" tsx-ts-mode)
       ))
    )
#+end_src

** code formatter
An automatic formatter to make your code a clean print.

With this package we can also prettify the c macro expansion, which is not prettified by default like lisp macros.

#+begin_src emacs-lisp
  (use-package format-all
    :ensure t
    :autoload (format-all--set-chain
               format-all--get-default-chain
               format-all-buffer
               )
    :custom
    (format-all-formatters '(("Shell" (shfmt "-i" "4"))))
    :bind
    (:map prog-mode-map
          ("C-x C-<tab>" . format-all-region)
          ("C-c C-<tab>" . format-all-buffer)
          )
    )

  (use-package cmacexp
    :functions (my:c-macro-expand)
    :config
    (defun my:c-macro-expand (start end subst)
      "Pass (START END SUBST) to c-macroexpand and format the output buffer."
      (interactive "r\nP")
      (c-macro-expand start end subst)
      (format-all--set-chain "C" (format-all--get-default-chain "C"))
      (let ((c-macro-buf (get-buffer c-macro-buffer-name)))
        (if (buffer-live-p c-macro-buf)
            (progn
              (switch-to-buffer c-macro-buf)
              (format-all-buffer)
              (switch-to-prev-buffer))
          nil))
      )
    :hook
    ((c-mode c++-mode)
     . (lambda () (keymap-local-set "C-c C-e" #'my:c-macro-expand)))
    )
#+end_src

** project management
Since Emacs 28, Emacs has integrated ~project.el~ for project management (its keymap is bound to ~C-x p~ by default). So we don't need projectile anymore. ~projection~ provides specific support for different types of projects.

~git~ is the most popular version control tool, and ~magit~ provides the best interface for it.

#+begin_src emacs-lisp
  (use-package projection
    :ensure t
    :after project
    :init
    (global-projection-hook-mode)
    :bind-keymap
    ("C-x P" . projection-map)
    )

  (use-package projection-multi
    :ensure t
    ;; Allow interactively selecting available compilation targets from
    ;; the current project type.
    :bind
    (:map projection-map
          ("RET" . projection-multi-compile))
    )

  ;; trigger bind to `C-x g' by default
  (use-package magit :ensure t)

  ;; License is necessary for your open-source projects
  (use-package lice :ensure t)
  (use-package spdx :ensure t)
#+end_src

** debugger
It is not a fashionable thing to debug in Emacs, most modern IDEs integrates their own debugger. However, that does not mean Emacs is not good at do that. Emacs has GUD (Generic Unified Debugger) as a frontend, which supports many debuggers, especially GDB.

#+begin_src emacs-lisp
  (use-package gud :diminish (gud-mode . " ÔÜà"))
#+end_src

Emacs have dap support now, and ~dap-mode~ is provided by emacs-lsp, which is a heavy framework on Elisp.  ~dape~ uses more built-in features for integration.

#+begin_src emacs-lisp
  (use-package dape :ensure t)
#+end_src

** language-specific supports
Most of them are not configured and deferred.

#+begin_src emacs-lisp
  ;; simple configuration for C/C++ build and debug.
  (use-package emacs
    :hook
    ((c-mode c++-mode)
     . (lambda () ;; one-key C file compilation
         (unless (or (null (buffer-file-name))
                     (file-exists-p "Makefile"))
           (let ((file (file-name-nondirectory buffer-file-name)))
             (set (make-local-variable 'compile-command)
                  ;; emulate make's .c.o implicit pattern rule, but with
                  ;; different defaults for the CC, CPPFLAGS, and CFLAGS
                  ;; variables:
                  ;; $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<
                  (format "%s -o %s %s %s %s"
                          (or (getenv "CC") "gcc")
                          (if (file-name-extension file)
                              (file-name-sans-extension file)
                            (concat file ".out"))
                          (or (getenv "CPPFLAGS") "-DDEBUG=9")
                          (or (getenv "CFLAGS") "-Wall -g")
                          file))
             ))
         (keymap-local-set "C-c C-r" #'compile)
         (keymap-local-set "C-c C-d" #'gud-gdb)))
    )

  (use-package tex
    :ensure auctex
    :config
    (if (package-installed-p 'pdf-tools)
        (progn
          (setf (alist-get 'output-pdf TeX-view-program-selection) '("PDF Tools"))
          (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
          )
      (setf (alist-get 'output-pdf TeX-view-program-selection) '("Zathura")))
    :hook
    (TeX-mode . TeX-fold-mode)
    (TeX-mode . (lambda () (run-hooks 'my/prog-mode-hook)))
    )

  (use-package lilypond-mode
    :mode ("\\.i?ly\\'" . LilyPond-mode)
    :custom
    ;; LilyPond does not support live preview, for live preview,
    ;; run the reader independently if it supports realtime updating.
    (LilyPond-ps-command "okular")
    (LilyPond-pdf-command "okular")
    )

  (use-package sclang
    :load-path "~/.local/share/SuperCollider/downloaded-quarks/scel/el"
    :mode ("\\.sc\\'" . sclang-mode)
    )

  (use-package racket-mode
    :ensure t
    :custom
    (racket-browse-url-function 'eww-browse-url)
    :hook (racket-mode . racket-xp-mode)
    )

  (use-package haskell-mode
    :ensure t
    :autoload (haskell-compile
               haskell-hoogle
               haskell-interactive-bring
               run-haskell)
    :bind
    (:map haskell-cabal-mode-map
          ("C-c C-c" . haskell-compile))
    )

  (use-package haskell-ts-mode
    :ensure t
    :custom
    (haskell-ts-highlight-signature t)
    :hook
    (haskell-ts-mode . (lambda () (setq mode-name "Haskell")))
    :bind
    ;; use commands provided by `inferior-haskell-mode'
    (:map haskell-ts-mode-map
          ("C-c C-c" . haskell-compile)
          ("C-c C-s" . haskell-hoogle)
          ("C-c C-d" . haskell-interactive-bring)
          ("C-c C-r" . run-haskell))
    )

  (use-package pyvenv
    :ensure t
    :diminish " Ôí∑ "
    :hook (python-mode . pyvenv-mode)
    )

  (use-package inf-lisp
    :init
    (setq inferior-lisp-program "ros -Q run")
    )

  (use-package slime
    :ensure t
    :diminish (slime-mode . " œö„ÇÄ")
    :custom
    (slime-autodoc-mode-string " œöi")
    :hook
    ;; EWW is enough for reading CommonLisp HyperSpec
    ((sldb-mode slime-mode slime-repl-mode)
     . (lambda () (setq-local browse-url-browser-function #'eww-browse-url)))
    )

  (use-package slime-repl-ansi-color
    :ensure t
    :diminish (slime-repl-ansi-color-mode . " œöÓ≠ú")
    :hook slime-repl-mode
    )

  (use-package auto-rename-tag
    :ensure t
    :diminish " Û∞Ö¥"
    :hook (nxml-mode . auto-rename-tag-mode)
    )

  (use-package markdown-mode
    :ensure t
    :mode ("README\\.md\\'" . gfm-mode)
    :custom
    (markdown-fontify-code-blocks-natively t)
    :bind
    (:map markdown-mode-map
          ("C-c C-x C-u" . markdown-toggle-url-hiding)
          ("C-c C-x C-l" . org-latex-preview))
    )

  (use-package geiser
    :ensure t
    :defines my:geiser-file-path
    :preface
    (defun my:geiser-file-path (name)
      (file-name-concat
       (my:strong-directory (file-name-concat user-emacs-directory "geiser/"))
       name))
    :custom
    (geiser-repl-history-filename (my:geiser-file-path ".geiser_history"))
    )

  (use-package geiser-chez
    :ensure t
    :after geiser
    :custom
    (geiser-chez-binary "chez")
    (geiser-chez-init-file (my:geiser-file-path ".chez-geiser"))
    )

  (use-package geiser-guile
    :ensure t
    :after geiser
    :custom
    (geiser-guile-init-file (my:geiser-file-path ".guile-geiser"))
    )

  (use-package plantuml-mode
    :ensure t
    :custom
    (plantuml-default-exec-mode 'executable)
    )

  (use-package web-mode
    :ensure t
    :mode
    ;; currently mhtml-mode is broken, mhtml-ts-mode hasn't been released
    ;; let's use web-mode instead
    (("\\.html\\'" . web-mode)
     ("\\.phtml\\'" . web-mode)
     ("\\.tpl\\.php\\'" . web-mode)
     ("\\.[agj]sp\\'" . web-mode)
     ("\\.as[cp]x\\'" . web-mode)
     ("\\.erb\\'" . web-mode)
     ("\\.mustache\\'" . web-mode)
     ("\\.djhtml\\'" . web-mode))
    )

  (use-package bison-mode :ensure t)
  (use-package disaster :ensure t)
  (use-package gnuplot :ensure t)
  (use-package go-mode :ensure t)
  (use-package graphviz-dot-mode :ensure t)
  (use-package lua-mode :ensure t)
  (use-package maxima :ensure t)
  (use-package tuareg :ensure t)
  (use-package proof-general :ensure t)
  (use-package riscv-mode :ensure t)
  (use-package rust-mode :ensure t)
  (use-package typescript-mode :ensure t)
#+end_src

* Org Editor
** org-mode
It is really interesting to write ~org-mode~ configurations in an org document.

#+begin_src emacs-lisp
  ;; org will load rmail and gnus when loading modules,
  ;; so the configuration of these modules must be placed before org.
  (use-package message
    :custom
    (message-directory
     (my:strong-directory (concat user-emacs-directory "Mail/")))
    )

  (use-package sendmail
    :custom
    (mail-default-directory
     (my:strong-directory (concat user-emacs-directory "sendmail/")))
    (mail-signature-file
     (concat mail-default-directory ".signature"))
    )

  (use-package gnus
    :commands (gnus)
    :custom
    (gnus-home-directory
     (my:strong-directory (concat user-emacs-directory "gnus/")))
    (gnus-directory
     (concat gnus-home-directory "News/"))
    (mail-source-directory message-directory)
    (smime-certificate-directory (concat message-directory "certs/"))
    :config
    (setq gnus-select-method '(nntp "news.gmane.io"))
    )

  (use-package org
    :autoload (org-babel-tangle-file)
    :defines org-mode-map
    :custom
    (org-directory (my:weak-directory "/wsp/doc/org"))
    (org-agenda-files (list (my:strong-directory (file-name-concat org-directory "roam/agenda"))))
    (org-default-notes-file (file-name-concat org-directory "notes.org"))
    (org-modules '(ol-doi ol-w3m ol-bbdb ol-bibtex ol-docview ol-gnus ol-info ol-irc ol-mhe ol-rmail ol-eww))
    (org-export-backends '(ascii html latex man md odt texinfo))
    (org-export-with-sub-superscripts nil)
    (org-fontify-inline-src-blocks t)
    (org-fontify-todo-headline t)
    (org-fontify-quote-and-verse-blocks t)
    (org-fontify-whole-block-delimiter-line t)
    (org-fontify-whole-heading-line t)
    (org-format-latex-options '(:foreground default :background "Transparent" :scale 1.0 :html-foreground auto :html-background "Transparent" :html-scale 1.0 :matchers ("begin" "$1" "$" "$$" "\\(" "\\[")))
    (org-hide-emphasis-markers t)
    (org-hide-leading-stars t)
    (org-hide-macro-markers t)
    (org-highlight-latex-and-related '(native latex script entities))
    (org-image-actual-width nil)
    (org-latex-compiler "xelatex")
    (org-latex-listings 'minted)
    (org-latex-packages-alist '(("" "color") ("" "minted") ("" "parskip") ("" "tikz") ("" "amsfonts") ("" "amsmath") ("" "amsthm")))
    (org-latex-pdf-process
     (if (executable-find "latexmk")
         '("latexmk -shell-escape -bibtex -f -pdf -%latex -interaction=nonstopmode -output-directory=%o %f")
       '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))
    (org-plantuml-jar-path "/usr/share/java/plantuml/plantuml.jar")
    (org-pretty-entities t)
    (org-pretty-entities-include-sub-superscripts nil)
    (org-support-shift-select t)
    (org-src-block-faces 'nil)
    (org-startup-folded 'content)
    (org-startup-with-inline-images my/load-gui-config-p)
    (org-todo-keywords '((sequence "PEND" "TODO" "DONE")))
    (org-todo-keyword-faces '(("PEND" . (:inherit fixed-pitch :foreground "#7FAFF0" :weight bold))))
    (org-use-sub-superscripts nil)
    :config
    ;; pdflatex is not very efficient, but only pdflatex supports tikz
    ;; original configuration use magick, but dvisvgm actually supports pdf
    (add-to-list
     'org-preview-latex-process-alist
     '(dvisvgm-pdf
       :programs ("latex" "dvisvgm") :description "pdf > svg"
       :message
       "you need to install the programs: latex and dvisvgm."
       :image-input-type "pdf" :image-output-type "svg"
       :image-size-adjust (1.0 . 1.0) :latex-compiler
       ("pdflatex -interaction nonstopmode -output-directory %o %f")
       :image-converter
       ("pdfcrop %f %f"
        "dvisvgm --pdf --no-fonts --exact --scale=%S %f --output=%O")))

    (setq org-preview-latex-default-process 'dvisvgm-pdf)

    ;; This must be deferred after `org-preview-latex-process-alist' is set
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t) (gnuplot . t) (plantuml . t) (dot . t) (shell . t) (latex . t) (lilypond . t)))

    ;; patch for org-9.7.* to display transparent png image.
    ;; it seems there is an Emacs bug to display transparency.
    (when (<= (string-to-number org-version) 9.7)
      (define-advice org--make-preview-overlay
          (:override (beg end image &optional imagetype))
        "Build an overlay between BEG and END using IMAGE file.
     Argument IMAGETYPE is the extension of the displayed image,
     as a string.  It defaults to \"png\"."
        (let ((ov (make-overlay beg end))
              (imagetype (or (intern imagetype) 'png)))
          (overlay-put ov 'org-overlay-type 'org-latex-overlay)
          (overlay-put ov 'evaporate t)
          (overlay-put ov
                       'modification-hooks
                       (list (lambda (o _flag _beg _end &optional _l)
                               (delete-overlay o))))
          (overlay-put ov
                       'display
                       (list 'image :type imagetype :file image :ascent 'center :mask 'heuristic))))
      )

    (mapc
     (lambda (kv)
       (setf (alist-get (car kv) org-src-lang-modes) (cdr kv)))
     '(("haskell" . haskell-ts)
       ("python" . python-ts)
       ("scheme" . scheme)
       ("lilypond" . LilyPond)))

    (defun my:org-toggle-emphasis-markers ()
      "Toggle visibility of emphasis markers in current buffer."
      (interactive)
      (set-variable 'org-hide-emphasis-markers (not org-hide-emphasis-markers))
      (org-restart-font-lock))

    ;; setup faces
    (when my/load-gui-config-p
      (apply
       #'my:map-set-face-attribute
       `((org-document-title nil :weight bold :height 1.5)
         ,@(mapcar
            (lambda (n) `(,(intern (format "org-level-%d" n)) nil
                     :weight bold :height ,(- 1.3 (* n 0.05)) :extend nil))
            (number-sequence 1 5))
         ,@(mapcar
            (lambda (face) `(,face nil :inherit (fixed-pitch)))
            '(org-block org-block-begin-line org-block-end-line org-hide org-meta-line org-property-value org-special-keyword org-table org-todo org-done org-checkbox org-drawer org-footnote org-link))
         ,@(mapcar
            (lambda (face) `(,face nil :inherit (fixed-pitch shadow)))
            '(org-code org-document-info-keyword org-verbatim org-tag))
         )))

    :hook
    (my/org-mode . (lambda () (when my/load-gui-config-p (setq line-spacing 0.1))))
    :bind
    (("C-c a" . org-agenda)
     ("C-c c" . org-capture)
     ("C-c l" . org-store-link)
     :map org-mode-map ;; override keybindings
     ("C-S-<left>"  . windower-move-border-left)
     ("C-S-<right>" . windower-move-border-right)
     ("C-S-<up>"    . windower-move-border-above)
     ("C-S-<down>"  . windower-move-border-below)
     :map org-src-mode-map
     ("C-c C-'" . separedit)
     )
    )

  (use-package org-capture
    :diminish (org-capture-mode . " Û∞ÑÄ")
    )
#+end_src

** org-roam
Roam builds a note database by inserting a unique ID to your org notes.

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :defines org-roam-cmd-map
    :custom
    (org-roam-directory (my:strong-directory (file-name-concat org-directory "roam/")))
    (org-roam-dailies-directory "dailies/")
    (org-roam-db-location (file-name-concat org-roam-directory "org-roam.db"))
    ;; Use FILE-TRUENAME to avoid expansion on this directory
    (org-roam-file-exclude-regexp '("data/" "ltximg/" ".*\\.assets/"))
    (org-roam-node-display-template
     (concat "${title} "
             (propertize "${tags}" 'face 'org-tag)
             (propertize " " 'display `((space :align-to (- right-fringe 20))))
             (propertize "${file-title}" 'face 'org-document-info)))
    :init
    (defvar org-roam-cmd-map (make-sparse-keymap)
      "A keymap for org-roam related commands.")

    (defun my:org-roam-consult-grep ()
      "Grep in org-roam-directory with `consult-grep'."
      (interactive)
      (consult-grep org-roam-directory ""))
    :config
    (org-roam-db-autosync-mode)
    :bind-keymap
    ("C-c n" . org-roam-cmd-map)
    :bind
    (:map org-roam-cmd-map
          ("l" . org-roam-buffer-toggle)
          ("f" . org-roam-node-find)
          ("g" . my:org-roam-consult-grep)
          ("i" . org-roam-node-insert)
          ("c" . org-roam-capture)
          ("j" . org-roam-dailies-capture-today)
          )
    )

  (use-package org-roam-ql
    :ensure t
    :bind
    (:map org-roam-cmd-map
          ("s" . org-roam-ql-search)
          ("v" . org-roam-ql-buffer-dispatch)
          )
    :hook (org-roam-ql-mode . visual-line-mode)
    )

  (use-package org-roam-ui
    :ensure t
    :diminish
    ((org-roam-ui-mode . " Û±óø")
     (org-roam-ui-follow-mode . " Ôëå "))
    :custom
    (org-roam-ui-open-on-start nil)
    :bind
    (:map org-roam-cmd-map
          ("u" . org-roam-ui-open)
          ("z" . org-roam-ui-node-zoom)
          )
    )

  (use-package org-roam-timestamps
    :ensure t
    :diminish org-roam-timestamps-mode
    :one-off-hook
    (org-mode . org-roam-timestamps-mode)
    )
#+end_src

** extensions
Other extensions that are helpful in ~org-mode~.

#+begin_src emacs-lisp
  (use-package org-appear
    :ensure t
    :custom
    (org-appear-autoemphasis t)
    (org-appear-autoentities t)
    (org-appear-autokeywords t)
    (org-appear-autolinks t)
    (org-appear-autosubmarkers t)
    (org-appear-inside-latex t)
    :hook (my/org-mode . org-appear-mode)
    )

  (use-package org-fragtog
    :ensure t
    :when my/load-gui-config-p
    :custom
    (org-fragtog-ignore-predicates '(org-at-block-p))
    :hook (my/org-mode . org-fragtog-mode)
    )

  (use-package org-download
    :ensure t
    :config
    (advice-add
     #'org-download--dir-1
     :override ;; this does not work for temporary buffers,
     (lambda () (concat "./" (file-name-base (buffer-file-name)) ".assets")))
    :custom
    (org-download-heading-lvl nil)
    (org-download-screenshot-method "spectacle -br -o %s")
    :bind
    (:map org-mode-map
          :prefix-map org-download-cmd-map
          :prefix "C-c y"
          ("c" . org-download-clipboard)
          ("e" . org-download-edit)
          ("i" . org-download-image)
          ("s" . org-download-screenshot)
          ("y" . org-download-yank)
          )
    :hook (my/org-mode . org-download-enable)
    )

  (use-package valign
    :ensure t
    :diminish (valign-mode . " Û∞â†")
    :when my/load-gui-config-p
    :hook ((my/org-mode markdown-mode) . valign-mode)
    )

  ;; play org document as slides
  (use-package org-tree-slide :ensure t)
  ;; for better org html output
  (use-package htmlize :ensure t)
#+end_src

* Emacs Desktop
** applications
There is a joke that Emacs is actually an operating system shell on lisp.

These applications are actually desktop-level, BTW I use Emacs.

#+begin_src emacs-lisp
  (use-package dirvish
    :ensure t
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-attributes
     '(vc-state subtree-state nerd-icons git-msg file-time file-size))
    :bind
    (("C-S-e" . dirvish-side)
     :map dirvish-mode-map
     ;; <tab> always translates to TAB by default
     ;; but C-<tab> won't translate to C-TAB
     ("TAB" . dirvish-subtree-toggle)
     ("C-<tab>" . dirvish-layout-toggle)
     ("<" . dirvish-history-last)
     (">" . dirvish-history-jump)
     ("?" . dirvish-dispatch)
     ("/" . dirvish-narrow)
     )
    )

  (use-package citar
    :ensure t
    :init
    (setq my/citar-bib-directory (my:weak-directory "/wsp/doc/bib"))
    :custom
    (citar-bibliography (when my/citar-bib-directory
                          (directory-files my/citar-bib-directory t ".*\\.bib")))
    :hook
    ((my/org-mode LaTeX-mode) . citar-capf-setup)
    :bind
    (:map org-mode-map
          ("C-c b" . org-cite-insert))
    )

  ;; embark integration
  (use-package citar-embark
    :ensure t
    :diminish citar-embark-mode
    :after (citar embark)
    :no-require
    :hook
    ((my/org-mode LaTeX-mode) . citar-embark-mode)
    )

  (use-package elfeed
    :ensure t
    :commands (elfeed)
    :custom
    (elfeed-db-directory (concat user-emacs-directory "elfeed"))
    (elfeed-enclosure-default-dir (concat user-emacs-directory "elfeed-enclosure"))
    (elfeed-feeds
     '("https://planet.emacslife.org/atom.xml"
       "https://phys.org/rss-feed/physics-news/physics/"
       "https://phys.org/rss-feed/space-news/astronomy/"
       "https://phys.org/rss-feed/earth-news/earth-sciences/"
       "https://xkcd.com/rss.xml"
       )
     )
    )

  (use-package gt
    :ensure t
    :autoload (gt-start
               gt-taker
               gt-translator)
    :init
    (defun my:gt-do-translate-quickly ()
      "Do a quick translate query with minibuffer prompt."
      (interactive)
      (gt-start
       (gt-translator
        :taker (gt-taker :prompt t)
        :engines (gt-stardict-engine)
        :render (gt-render))))

    :config
    (setq
     gt-http-backend (pdd-url-backend)
     gt-http-proxy (or (getenv "http_proxy") (getenv "ALL_PROXY"))
     gt-langs '(en zh)
     gt-preset-translators
     `((ts-word
        . ,(gt-translator
            :taker (gt-taker)
            :engines (list (gt-youdao-dict-engine)
                           (gt-google-engine))
            :render (gt-buffer-render)))
       (ts-offline
        . ,(gt-translator
            :taker (gt-taker)
            :engines (list (gt-stardict-engine))
            ;; download stardict from https://kdr2.com/resource/stardict.html
            :render (gt-render)))
       (ts-offline-prompt
        . ,(gt-translator
            :taker (gt-taker :prompt t)
            :engines (list (gt-stardict-engine))
            :render (gt-render)))
       (ts-paragraph
        . ,(gt-translator
            :taker (gt-taker :text 'paragraph :pick 'paragraph)
            :engines (gt-google-rpc-engine)
            :render (gt-buffer-render)))
       (ts-buffer
        . ,(gt-translator
            :taker (gt-taker :text 'buffer :pick 'paragraph)
            :engines (gt-google-rpc-engine)
            :render (gt-buffer-render)))
       (ts-buffer-replace
        . ,(gt-translator
            :taker (gt-taker :text 'buffer :pick 'paragraph)
            :engines (gt-google-rpc-engine)
            :render (gt-insert-render :type 'replace)))
       (ts-buffer-prompt
        . ,(gt-translator
            :taker (gt-taker :prompt 'buffer :text 'buffer :pick 'paragraph)
            :engines (gt-google-rpc-engine)
            :render (gt-buffer-render)))
       ))

    :bind
    ("M-\"" . gt-translate) ;; press C-n and C-p to loop languages
    ("C-M-\"" . my:gt-do-translate-quickly)
    )

  (use-package pdf-tools
    :ensure t
    :init
    (pdf-loader-install)
    )

  (use-package nov
    :ensure t
    :mode ("\\.epub\\'" . nov-mode)
    )

  ;; not configured yet
  (use-package djvu :ensure t)
#+end_src

** developer tools
Tools for Emacs development.

You may disable this block if you are not ready to be deliver packages to community.

#+begin_src emacs-lisp
  (use-package package-lint
    :ensure t
    :autoload (package-lint-buffer)
    :init
    (defun my:pacakge-lint-file (&optional filename)
      "Display lint errors and warnings for a file of FILENAME."
      (interactive
       (list (or (buffer-file-name)
                 (read-file-name "Lint file: "))))
      (let ((errs (package-lint-buffer (find-file filename)))
            (buf "*Package-Lint*"))
        (with-current-buffer (get-buffer-create buf)
          (let ((buffer-read-only nil))
            (erase-buffer)
            (cond
             ((null errs) (insert "No issues found."))
             ((null (cdr errs)) (insert "1 issue found:\n\n"))
             (t (insert (format "%d issues found:\n\n" (length errs)))))
            (pcase-dolist (`(,line ,col ,type ,message) errs)
              (insert (format "%s:%d:%d: %s: %s\n" filename line col type message))))
          (compilation-mode buf))
        (display-buffer buf)))
    )

  (use-package package-build :ensure t)
#+end_src

* Epilogue
** miscellaneous utilities
My own packages, you can get them from github with ~vc-use-package~.
#+begin_src emacs-lisp
  (use-package my-misc
    :vc (:url "https://github.com/gynamics/my-misc.el")
    :defer nil
    :bind
    ("M-#"   . my:mark-whole-line)
    ("M-Q"   . my:unfill-paragraph)
    ("C-x %" . my:eval-and-replace)
    ("C-x 9" . my:dedicate-window-toggle)
    ("<f9>"  . my:adjust-alpha-background)
    )

  (use-package semantic-pkg-config
    :vc (:url "https://github.com/gynamics/semantic-pkg-config.el")
    )

  (use-package railgun
    :vc (:url "https://github.com/gynamics/railgun.el")
    )

  (use-package toc-glue
    :vc (:url "https://github.com/gynamics/toc-glue.el")
    :mode
    ("\\.toc\\'" . toc-mode)
    ("\\.bm.lisp\\'" . toc-glue-mode)
    ("\\.djvubm.lisp\\'" . toc-glue-djvu-mode)
    )

  (use-package oboe
    :vc (:url "https://github.com/gynamics/oboe.el")
    :init
    (defun my:ibuffer-oboe-absorb ()
      "Absorb marked buffers into an OBOE temporary buffer."
      (interactive)
      (oboe-absorb (ibuffer-get-marked-buffers)))
    :custom
    (oboe-default-display-method 'popwin:popup-buffer)
    :bind
    (:map ibuffer-mode-map :package ibuffer
          ("a" . my:ibuffer-oboe-absorb))
    )
#+end_src

** miscellaneous configurations

#+begin_src emacs-lisp
  (use-package recentf
    :init
    (recentf-mode)
    :custom
    (recentf-max-saved-items 64)
    :config
    ;; do not waste time on checking remote files
    (add-to-list 'recentf-keep 'file-remote-p)
    )

  (use-package abbrev :diminish  (abbrev-mode . " Ó≠æ "))
  (use-package autorevert :diminish (auto-revert-mode . " Ôáö "))

  (use-package face-remap
    :diminish (buffer-face-mode . " Óà´ ")
    :hook
    (my/prog-mode . buffer-face-mode)
    (my/org-mode . variable-pitch-mode)
    :bind ("C-c v b" . buffer-face-mode)
    )

  (use-package whitespace
    :diminish (whitespace-mode . " ÔÇñ ")
    :bind ("C-c v SPC" . whitespace-mode)
    )

  (use-package prog-mode
    :hook
    (my/prog-mode . prettify-symbols-mode)
    (my/prog-mode . display-line-numbers-mode)
    (my/prog-mode
     . (lambda () ;; cleanup whitespaces on save.
         (make-local-variable 'before-save-hook)
         (add-hook 'before-save-hook ;; make it buffer-local
                   #'(lambda () (whitespace-cleanup)) nil t)))
    )

  (use-package pp
    :init
    (define-advice pp-display-expression
        (:override (expression out-buffer-name &optional lisp))
      "A hacked version which always use `popwin:popup-buffer' for display."
      (let* ((lexical lexical-binding)
             (old-show-function temp-buffer-show-function)
             (temp-buffer-show-function #'popwin:popup-buffer))
        (with-output-to-temp-buffer out-buffer-name
          (if lisp
              (with-current-buffer standard-output
                (pp-emacs-lisp-code expression))
            (pp expression))
          (with-current-buffer standard-output
            (emacs-lisp-mode)
            (setq lexical-binding lexical)
            (setq buffer-read-only nil)
            (setq-local font-lock-verbose nil)))))
    )

  ;; some general configurations
  (use-package emacs
    :custom
    (blink-cursor-mode nil)
    (buffer-face-mode-face 'default)
    (column-number-mode t)
    (delete-by-moving-to-trash t)
    (fill-column 80)
    (indent-tabs-mode nil)
    (inhibit-startup-screen t)
    (native-comp-async-report-warnings-errors nil)
    (prettify-symbols-unprettify-at-point 'right-edge)
    (scroll-bar-mode nil)
    (size-indication-mode t)
    (tab-always-indent t)
    (tool-bar-mode nil)
    (undo-limit (expt 2 20))
    ;; do not make backups
    (make-backup-files nil)
    ;; or, save backups in a specific directory if necessary
    ;; (backup-directory-alist
    ;;  `(("." . ,(concat user-emacs-directory "backups")))
    :bind
    ([remap list-buffers]    . ibuffer)
    ([remap eval-last-sexp]  . pp-eval-last-sexp)
    ([remap eval-expression] . pp-eval-expression)
    ([remap dabbrev-expand]  . hippie-expand)
    ("C-x M-e" . pp-macroexpand-last-sexp)
    ("C-x M-s" . macrostep-mode)
    ("C-x M-." . xref-find-definitions)
    )

  ;; update list of selected packages
  (setq
   package-selected-packages use-package-selected-packages
   package-vc-selected-packages use-package-vc-selected-packages)

  ;; enable some disabled functions
  (put 'downcase-region 'disabled nil) ;; C-x C-l
  (put 'upcase-region 'disabled nil)   ;; C-x C-u
#+end_src

** footer

#+begin_src emacs-lisp
  (provide 'koishimacs)
  ;;; koishimacs.el ends here
#+end_src

** postscript
Evaluate these expressions after bootstrap to complete the installation, never tangle this block!

#+begin_src emacs-lisp :tangle no
  ;; install font for `nerd-icons'
  (nerd-icons-install-fonts)

  ;; run this code once to install all treesit libraries at once (not necessary)
  (mapc #'treesit-install-language-grammar
        (mapcar #'car treesit-language-source-alist))

#+end_src
